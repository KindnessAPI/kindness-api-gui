{"version":3,"sources":["webpack://LoadBall/./src/engine-visual/geosim/gpgpu.js","webpack://LoadBall/./src/engine-visual/geosim/geosim.js","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue?a733","webpack://LoadBall/src/engine-visual/ActiveLearningART.vue","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue?d19d","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","variables","currentTextureIndex","scene","THREE","camera","position","z","passThruUniforms","texture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","add","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","NearestFilter","push","setVariableDependencies","init","extensions","get","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","renderTarget","format","type","test","navigator","userAgent","stencilBuffer","depthBuffer","createTexture","a","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render","glsl","x","simulatePosition","simulateState","makeAPI","api","WIDTH","gpuCompute","pos0","color0","meta0","posVar","colorVar","time","error","console","geo","processMeta","iii","dimension","Math","pow","total","ARR_VALUE","image","data","ix","iy","iz","id","floor","getUV","uv","uvi","getPosition","newArr","na","addAttribute","geoShader","colorShader","transparent","side","DoubleSide","background","window","performance","now","clean","remove"],"mappings":"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","file":"LoadBall.common.content.js","sourcesContent":["/* eslint-disable */\n/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\n/*\neslint-disable\n*/\nimport * as THREE from 'three'\nexport default function GPUComputationRenderer( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\ttexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function() {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function() {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\t};\n\n\tthis.getCurrentRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\n\t}\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? THREE.HalfFloatType : THREE.FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function() {\n\n\t\tvar a = new Float32Array( sizeX * sizeY * 4 );\n\t\tvar texture = new THREE.DataTexture( a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\tthis.renderTexture = function( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.texture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output);\n\n\t\tpassThruUniforms.texture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function( material, output ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tmesh.material = material;\n\t\trenderer.setRenderTarget( output );\n\t\trenderer.render( scene, camera );\n\t\tmesh.material = passThruShader;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D texture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( texture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n}\n","import * as THREE from 'three'\nimport GPUComputationRenderer from './gpgpu.js'\n\nlet glsl = x => x[0]\n\nlet simulatePosition = glsl`\n  /*\n    LIBRARY\n  */\n  #include <common>\n\n  mat3 rotateX (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      1.0, 0.0, 0.0,\n      0.0, c, s,\n      0.0, -s, c\n    );\n  }\n\n  mat3 rotateY (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      c, 0.0, -s,\n      0.0, 1.0, 0.0,\n      s, 0.0, c\n    );\n  }\n\n  mat3 rotateZ (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      c, s, 0.0,\n      -s, c, 0.0,\n      0.0, 0.0, 1.0\n    );\n  }\n\n  mat3 rotateQ (vec3 axis, float rad) {\n    float hr = rad / 2.0;\n    float s = sin( hr );\n    vec4 q = vec4(axis * s, cos( hr ));\n    vec3 q2 = q.xyz + q.xyz;\n    vec3 qq2 = q.xyz * q2;\n    vec2 qx = q.xx * q2.yz;\n    float qy = q.y * q2.z;\n    vec3 qw = q.w * q2.xyz;\n\n    return mat3(\n      1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,\n      qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,\n      qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)\n    );\n  }\n\n  /*\n    Position Main Code\n  */\n  precision highp sampler2D;\n  uniform sampler2D meta0;\n  uniform float time;\n\n  void main (void) {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec4 LAST_POS = texture2D(texturePosition, uv);\n    vec4 META0 = texture2D(meta0, uv);\n    vec4 pos = vec4(0.0);\n\n    float vertexIDX = META0.x;\n    float squareIDX = META0.y;\n    float totalSquares = META0.z;\n    float pointIDX = META0.w;\n\n    /*\n      Assemble\n    */\n    vec3 plane = vec3(0.6, 0.3, 0.0);\n    bool isInvalid = false;\n    if (vertexIDX == 0.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 1.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 2.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 3.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 4.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 5.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else {\n      isInvalid = true;\n    }\n\n    if (!isInvalid) {\n      float dimension = (pow(totalSquares, 0.5));\n\n      vec3 offset = vec3(\n        plane.x * 15.25 * (squareIDX / dimension),\n        plane.y * 1.0 * (mod(squareIDX, dimension)),\n        plane.z * 0.0\n      );\n\n      pos.xyz += offset.xyz;\n\n      float pX = pos.x;\n      float pY = pos.y;\n      float pZ = pos.y;\n\n      float piz = 0.001 * 2.0 * 3.14159265;\n\n      pos.xyz = rotateQ(normalize(vec3(1.0, pZ * piz, 1.0)), time + pX * piz) * rotateY(time + pY * piz) * pos.xyz;\n      pos.z += sin(time  + pX * piz * 0.333) * 50.0;\n\n      pos.xyz *= 0.075;\n\n      pos.w = 1.0;\n      gl_FragColor = pos;\n    } else {\n      pos.w = 0.0;\n      gl_FragColor = pos;\n    }\n  }\n`\n\nlet simulateState = glsl`\n  /*\n    LIBRARY\n  */\n  #include <common>\n\n  /*\n    Simulation Main Code\n  */\n  uniform float time;\n  uniform sampler2D meta0;\n  void main (void) {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec4 LAST_COLOR = texture2D(textureColor, uv);\n    vec4 META0 = texture2D(meta0, uv);\n\n    float vertexIDX = META0.x;\n    float squareIDX = META0.y;\n    float totalSquares = META0.z;\n    float pointIDX = META0.w;\n\n    float red = uv.x + 0.5;\n    float green = uv.y + 0.5;\n    float blue = 0.5;\n\n    gl_FragColor = vec4(red, green, blue, 1.0);\n  }\n`\n\nexport const makeAPI = ({ renderer, scene }) => {\n  let api = {\n    render () {}\n  }\n  let WIDTH = 1024\n\n  let gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n\n  let pos0 = gpuCompute.createTexture()\n  let color0 = gpuCompute.createTexture()\n\n  // meta0\n  let meta0 = gpuCompute.createTexture()\n\n  let posVar = gpuCompute.addVariable('texturePosition', simulatePosition, pos0)\n  let colorVar = gpuCompute.addVariable('textureColor', simulateState, color0)\n\n  // Add variable dependencies\n  gpuCompute.setVariableDependencies(posVar, [posVar])\n  gpuCompute.setVariableDependencies(colorVar, [colorVar])\n\n  // pos var\n  posVar.material.uniforms.time = { value: 0.0 }\n  posVar.material.uniforms.meta0 = { value: meta0 }\n\n  // state var\n  colorVar.material.uniforms.time = { value: 0.0 }\n  colorVar.material.uniforms.meta0 = { value: meta0 }\n\n  // Check for completeness\n  let error = gpuCompute.init()\n  if (error !== null) {\n    console.error(error)\n  }\n\n  let geo = new THREE.BufferGeometry()\n\n  let processMeta = () => {\n    let iii = 0\n    let dimension = Math.pow(WIDTH * WIDTH, 1 / 3)\n    let total = dimension * dimension * dimension\n    // let dimension05 = dimension / 2\n\n    let ARR_VALUE = meta0.image.data\n    for (var ix = 0; ix < dimension; ix++) {\n      for (var iy = 0; iy < dimension; iy++) {\n        for (var iz = 0; iz < dimension; iz++) {\n          // console.log(iii)\n          let id = iii / 4\n\n          ARR_VALUE[iii + 0] = id % 6 // square vertex ID\n          ARR_VALUE[iii + 1] = Math.floor(id / 6) // square ID\n          ARR_VALUE[iii + 2] = total / 6.0 // percentage\n\n          // dot id\n          ARR_VALUE[iii + 3] = id // point ID\n\n          iii += 4\n        }\n      }\n    }\n  }\n  processMeta()\n\n  let getUV = () => {\n    let uv = []\n    let uvi = 0\n    for (var j = 0; j < WIDTH; j++) {\n      for (var i = 0; i < WIDTH; i++) {\n        uv[uvi + 0] = i / WIDTH\n        uv[uvi + 1] = j / WIDTH\n\n        uvi += 2\n      }\n    }\n    return uv\n  }\n\n  let getPosition = () => {\n    let newArr = []\n    var na = 0\n    // let W5 = WIDTH * 0.5\n    for (var j = 0; j < WIDTH; j++) {\n      for (var i = 0; i < WIDTH; i++) {\n        newArr[na + 0] = 0 // (i - W5)\n        newArr[na + 1] = 0 // (j - W5)\n        newArr[na + 2] = 0\n        na += 3\n      }\n    }\n    return newArr\n  }\n\n  geo.addAttribute('position', new THREE.Float32BufferAttribute(getPosition(), 3))\n  geo.addAttribute('uv', new THREE.Float32BufferAttribute(getUV(), 2))\n\n  var uniforms = {\n    time: { value: 0 },\n    geoShader: { value: null },\n    colorShader: { value: null }\n  }\n\n  var material = new THREE.ShaderMaterial({\n    transparent: true,\n    uniforms,\n    defines: {\n      resolution: `vec2(${WIDTH.toFixed(1)}, ${WIDTH.toFixed(1)})`\n    },\n    vertexShader: glsl`\n      precision highp float;\n      precision highp sampler2D;\n\n      varying highp vec2 vUv;\n      varying highp vec3 vPos;\n\n      uniform sampler2D geoShader;\n      void main () {\n        vUv = uv;\n        vec4 posTex = texture2D(geoShader, uv);\n        gl_PointSize = 1.0;\n        vPos = posTex.xyz;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(posTex.xyz, posTex.w);\n      }\n    `,\n    fragmentShader: glsl`\n      precision highp float;\n      precision highp sampler2D;\n\n      uniform sampler2D colorShader;\n      varying highp vec2 vUv;\n      varying highp vec3 vPos;\n      void main () {\n        vec4 colorVal = texture2D(colorShader, vUv);\n        gl_FragColor = vec4(vec3(\n          vPos.x / 100.0 * 0.6 + 0.5,\n          vPos.y / 100.0 * 0.6 + 0.5,\n          vPos.z / 100.0 * 0.6 + 0.5\n        ), 0.9);\n      }\n    `,\n    side: THREE.DoubleSide\n  })\n  let mesh = new THREE.Mesh(geo, material)\n  scene.add(mesh)\n\n  scene.background = new THREE.Color('#ffffff')\n  api.render = () => {\n    // Update texture uniforms in your visualization materials with the gpu renderer output\n    material.uniforms.geoShader.value = gpuCompute.getCurrentRenderTarget(posVar).texture\n    material.uniforms.colorShader.value = gpuCompute.getCurrentRenderTarget(colorVar).texture\n\n    let time = window.performance.now() * 0.001\n    posVar.material.uniforms.time.value = time\n    colorVar.material.uniforms.time.value = time\n    gpuCompute.compute()\n  }\n\n  api.clean = () => {\n    scene.remove(mesh)\n  }\n\n  return api\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div')}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div>\n  </div>\n</template>\n\n<script>\nlet GLAPI = require('./geosim/geosim.js')\n\nexport default {\n  props: {\n    engine: {}\n  },\n  data () {\n    return {\n      api: {}\n    }\n  },\n  mounted () {\n    this.setup()\n  },\n  methods: {\n    async setup () {\n      this.api = GLAPI.makeAPI({ renderer: this.engine.renderer, scene: this.engine.scene })\n      this.engine.execStack.renderActiveLearningART = () => {\n        this.api.render()\n      }\n    }\n  },\n  beforeDestroy () {\n    this.api.clean()\n    this.engine.execStack.renderActiveLearningART = () => {}\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActiveLearningART.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActiveLearningART.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./ActiveLearningART.vue?vue&type=template&id=4e3b59d2&\"\nimport script from \"./ActiveLearningART.vue?vue&type=script&lang=js&\"\nexport * from \"./ActiveLearningART.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}