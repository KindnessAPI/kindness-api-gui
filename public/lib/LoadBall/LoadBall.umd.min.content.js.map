{"version":3,"sources":["webpack://LoadBall/./src/engine-visual/geosim/gpgpu.js","webpack://LoadBall/./src/engine-visual/geosim/geosim.js","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue?a733","webpack://LoadBall/src/engine-visual/ActiveLearningART.vue","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue?d19d","webpack://LoadBall/./src/engine-visual/ActiveLearningART.vue"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","this","variables","currentTextureIndex","scene","THREE","camera","position","z","passThruUniforms","texture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","vertexShader","getPassThroughVertexShader","fragmentShader","add","addVariable","variableName","initialValueTexture","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","extensions","get","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","d","depVar","found","j","compute","nextTextureIndex","il","dl","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","renderTarget","format","type","test","navigator","userAgent","stencilBuffer","depthBuffer","createTexture","a","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render","glsl","x","simulatePosition","_templateObject","simulateState","_templateObject2","makeAPI","_ref","api","WIDTH","gpuCompute","pos0","color0","meta0","posVar","colorVar","time","error","console","geo","processMeta","iii","dimension","Math","pow","total","ARR_VALUE","image","data","ix","iy","iz","id","floor","getUV","uv","uvi","getPosition","newArr","na","addAttribute","geoShader","colorShader","transparent","concat","_templateObject3","_templateObject4","side","background","window","performance","now","clean","remove","_vm","_h","$createElement","_c","_self","staticRenderFns","GLAPI","__webpack_require__","ActiveLearningARTvue_type_script_lang_js_","props","engine","mounted","setup","methods","_setup","Object","asyncToGenerator","regeneratorRuntime","mark","_callee","_this","wrap","_context","prev","next","execStack","renderActiveLearningART","stop","apply","arguments","beforeDestroy","engine_visual_ActiveLearningARTvue_type_script_lang_js_","component","componentNormalizer","__webpack_exports__"],"mappings":"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","file":"LoadBall.umd.min.content.js","sourcesContent":["/* eslint-disable */\n/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\n/*\neslint-disable\n*/\nimport * as THREE from 'three'\nexport default function GPUComputationRenderer( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\ttexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function() {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function() {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\t};\n\n\tthis.getCurrentRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\n\t}\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? THREE.HalfFloatType : THREE.FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function() {\n\n\t\tvar a = new Float32Array( sizeX * sizeY * 4 );\n\t\tvar texture = new THREE.DataTexture( a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\tthis.renderTexture = function( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.texture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output);\n\n\t\tpassThruUniforms.texture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function( material, output ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tmesh.material = material;\n\t\trenderer.setRenderTarget( output );\n\t\trenderer.render( scene, camera );\n\t\tmesh.material = passThruShader;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D texture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( texture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n}\n","import * as THREE from 'three'\nimport GPUComputationRenderer from './gpgpu.js'\n\nlet glsl = x => x[0]\n\nlet simulatePosition = glsl`\n  /*\n    LIBRARY\n  */\n  #include <common>\n\n  mat3 rotateX (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      1.0, 0.0, 0.0,\n      0.0, c, s,\n      0.0, -s, c\n    );\n  }\n\n  mat3 rotateY (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      c, 0.0, -s,\n      0.0, 1.0, 0.0,\n      s, 0.0, c\n    );\n  }\n\n  mat3 rotateZ (float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n      c, s, 0.0,\n      -s, c, 0.0,\n      0.0, 0.0, 1.0\n    );\n  }\n\n  mat3 rotateQ (vec3 axis, float rad) {\n    float hr = rad / 2.0;\n    float s = sin( hr );\n    vec4 q = vec4(axis * s, cos( hr ));\n    vec3 q2 = q.xyz + q.xyz;\n    vec3 qq2 = q.xyz * q2;\n    vec2 qx = q.xx * q2.yz;\n    float qy = q.y * q2.z;\n    vec3 qw = q.w * q2.xyz;\n\n    return mat3(\n      1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,\n      qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,\n      qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)\n    );\n  }\n\n  /*\n    Position Main Code\n  */\n  precision highp sampler2D;\n  uniform sampler2D meta0;\n  uniform float time;\n\n  void main (void) {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec4 LAST_POS = texture2D(texturePosition, uv);\n    vec4 META0 = texture2D(meta0, uv);\n    vec4 pos = vec4(0.0);\n\n    float vertexIDX = META0.x;\n    float squareIDX = META0.y;\n    float totalSquares = META0.z;\n    float pointIDX = META0.w;\n\n    /*\n      Assemble\n    */\n    vec3 plane = vec3(0.6, 0.3, 0.0);\n    bool isInvalid = false;\n    if (vertexIDX == 0.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 1.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 2.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 3.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = 1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 4.0) {\n      pos.x = -1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else if (vertexIDX == 5.0) {\n      pos.x = 1.0 * plane.x;\n      pos.y = -1.0 * plane.y;\n      pos.z = 1.0 * plane.z;\n    } else {\n      isInvalid = true;\n    }\n\n    if (!isInvalid) {\n      float dimension = (pow(totalSquares, 0.5));\n\n      vec3 offset = vec3(\n        plane.x * 15.25 * (squareIDX / dimension),\n        plane.y * 1.0 * (mod(squareIDX, dimension)),\n        plane.z * 0.0\n      );\n\n      pos.xyz += offset.xyz;\n\n      float pX = pos.x;\n      float pY = pos.y;\n      float pZ = pos.y;\n\n      float piz = 0.001 * 2.0 * 3.14159265;\n\n      pos.xyz = rotateQ(normalize(vec3(1.0, pZ * piz, 1.0)), time + pX * piz) * rotateY(time + pY * piz) * pos.xyz;\n      pos.z += sin(time  + pX * piz * 0.333) * 50.0;\n\n      pos.xyz *= 0.075;\n\n      pos.w = 1.0;\n      gl_FragColor = pos;\n    } else {\n      pos.w = 0.0;\n      gl_FragColor = pos;\n    }\n  }\n`\n\nlet simulateState = glsl`\n  /*\n    LIBRARY\n  */\n  #include <common>\n\n  /*\n    Simulation Main Code\n  */\n  uniform float time;\n  uniform sampler2D meta0;\n  void main (void) {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec4 LAST_COLOR = texture2D(textureColor, uv);\n    vec4 META0 = texture2D(meta0, uv);\n\n    float vertexIDX = META0.x;\n    float squareIDX = META0.y;\n    float totalSquares = META0.z;\n    float pointIDX = META0.w;\n\n    float red = uv.x + 0.5;\n    float green = uv.y + 0.5;\n    float blue = 0.5;\n\n    gl_FragColor = vec4(red, green, blue, 1.0);\n  }\n`\n\nexport const makeAPI = ({ renderer, scene }) => {\n  let api = {\n    render () {}\n  }\n  let WIDTH = 1024\n\n  let gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n\n  let pos0 = gpuCompute.createTexture()\n  let color0 = gpuCompute.createTexture()\n\n  // meta0\n  let meta0 = gpuCompute.createTexture()\n\n  let posVar = gpuCompute.addVariable('texturePosition', simulatePosition, pos0)\n  let colorVar = gpuCompute.addVariable('textureColor', simulateState, color0)\n\n  // Add variable dependencies\n  gpuCompute.setVariableDependencies(posVar, [posVar])\n  gpuCompute.setVariableDependencies(colorVar, [colorVar])\n\n  // pos var\n  posVar.material.uniforms.time = { value: 0.0 }\n  posVar.material.uniforms.meta0 = { value: meta0 }\n\n  // state var\n  colorVar.material.uniforms.time = { value: 0.0 }\n  colorVar.material.uniforms.meta0 = { value: meta0 }\n\n  // Check for completeness\n  let error = gpuCompute.init()\n  if (error !== null) {\n    console.error(error)\n  }\n\n  let geo = new THREE.BufferGeometry()\n\n  let processMeta = () => {\n    let iii = 0\n    let dimension = Math.pow(WIDTH * WIDTH, 1 / 3)\n    let total = dimension * dimension * dimension\n    // let dimension05 = dimension / 2\n\n    let ARR_VALUE = meta0.image.data\n    for (var ix = 0; ix < dimension; ix++) {\n      for (var iy = 0; iy < dimension; iy++) {\n        for (var iz = 0; iz < dimension; iz++) {\n          // console.log(iii)\n          let id = iii / 4\n\n          ARR_VALUE[iii + 0] = id % 6 // square vertex ID\n          ARR_VALUE[iii + 1] = Math.floor(id / 6) // square ID\n          ARR_VALUE[iii + 2] = total / 6.0 // percentage\n\n          // dot id\n          ARR_VALUE[iii + 3] = id // point ID\n\n          iii += 4\n        }\n      }\n    }\n  }\n  processMeta()\n\n  let getUV = () => {\n    let uv = []\n    let uvi = 0\n    for (var j = 0; j < WIDTH; j++) {\n      for (var i = 0; i < WIDTH; i++) {\n        uv[uvi + 0] = i / WIDTH\n        uv[uvi + 1] = j / WIDTH\n\n        uvi += 2\n      }\n    }\n    return uv\n  }\n\n  let getPosition = () => {\n    let newArr = []\n    var na = 0\n    // let W5 = WIDTH * 0.5\n    for (var j = 0; j < WIDTH; j++) {\n      for (var i = 0; i < WIDTH; i++) {\n        newArr[na + 0] = 0 // (i - W5)\n        newArr[na + 1] = 0 // (j - W5)\n        newArr[na + 2] = 0\n        na += 3\n      }\n    }\n    return newArr\n  }\n\n  geo.addAttribute('position', new THREE.Float32BufferAttribute(getPosition(), 3))\n  geo.addAttribute('uv', new THREE.Float32BufferAttribute(getUV(), 2))\n\n  var uniforms = {\n    time: { value: 0 },\n    geoShader: { value: null },\n    colorShader: { value: null }\n  }\n\n  var material = new THREE.ShaderMaterial({\n    transparent: true,\n    uniforms,\n    defines: {\n      resolution: `vec2(${WIDTH.toFixed(1)}, ${WIDTH.toFixed(1)})`\n    },\n    vertexShader: glsl`\n      precision highp float;\n      precision highp sampler2D;\n\n      varying highp vec2 vUv;\n      varying highp vec3 vPos;\n\n      uniform sampler2D geoShader;\n      void main () {\n        vUv = uv;\n        vec4 posTex = texture2D(geoShader, uv);\n        gl_PointSize = 1.0;\n        vPos = posTex.xyz;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(posTex.xyz, posTex.w);\n      }\n    `,\n    fragmentShader: glsl`\n      precision highp float;\n      precision highp sampler2D;\n\n      uniform sampler2D colorShader;\n      varying highp vec2 vUv;\n      varying highp vec3 vPos;\n      void main () {\n        vec4 colorVal = texture2D(colorShader, vUv);\n        gl_FragColor = vec4(vec3(\n          vPos.x / 100.0 * 0.6 + 0.5,\n          vPos.y / 100.0 * 0.6 + 0.5,\n          vPos.z / 100.0 * 0.6 + 0.5\n        ), 0.9);\n      }\n    `,\n    side: THREE.DoubleSide\n  })\n  let mesh = new THREE.Mesh(geo, material)\n  scene.add(mesh)\n\n  scene.background = new THREE.Color('#ffffff')\n  api.render = () => {\n    // Update texture uniforms in your visualization materials with the gpu renderer output\n    material.uniforms.geoShader.value = gpuCompute.getCurrentRenderTarget(posVar).texture\n    material.uniforms.colorShader.value = gpuCompute.getCurrentRenderTarget(colorVar).texture\n\n    let time = window.performance.now() * 0.001\n    posVar.material.uniforms.time.value = time\n    colorVar.material.uniforms.time.value = time\n    gpuCompute.compute()\n  }\n\n  api.clean = () => {\n    scene.remove(mesh)\n  }\n\n  return api\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div')}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div>\n  </div>\n</template>\n\n<script>\nlet GLAPI = require('./geosim/geosim.js')\n\nexport default {\n  props: {\n    engine: {}\n  },\n  data () {\n    return {\n      api: {}\n    }\n  },\n  mounted () {\n    this.setup()\n  },\n  methods: {\n    async setup () {\n      this.api = GLAPI.makeAPI({ renderer: this.engine.renderer, scene: this.engine.scene })\n      this.engine.execStack.renderActiveLearningART = () => {\n        this.api.render()\n      }\n    }\n  },\n  beforeDestroy () {\n    this.api.clean()\n    this.engine.execStack.renderActiveLearningART = () => {}\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActiveLearningART.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActiveLearningART.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./ActiveLearningART.vue?vue&type=template&id=4e3b59d2&\"\nimport script from \"./ActiveLearningART.vue?vue&type=script&lang=js&\"\nexport * from \"./ActiveLearningART.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}